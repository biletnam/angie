<?php
/**
 * ANGIE - The site restoration script for backup archives created by Akeeba Backup and Akeeba Solo
 *
 * @package   angie
 * @copyright Copyright (c)2009-2019 Nicholas K. Dionysopoulos / Akeeba Ltd
 * @license   http://www.gnu.org/copyleft/gpl.html GNU/GPL v3 or later
 */

defined('_AKEEBA') or die();

class AngieModelWordpressFinalise extends AngieModelBaseFinalise
{
	/**
	 * Handle the .htaccess file update
	 *
	 * Due to the multitude of complicated ways WordPress can be set up and the non-standardized format of the .htaccess
	 * rules generated by its plugins it is possible that the
	 *
	 * Session variables created by this method:
	 *
	 * htaccessRequired     Do I actually NEED to change the .htaccess file?
	 * htaccessRenamed      Have I successfully renamed the current .htaccess to .htaccess.akeebabackup
	 * htaccessGenerated    Have I successfully written a new .htaccess file?
	 * htaccessContents     The contents of the .htaccess file you need to create manually
	 *
	 * @return  bool
	 */
	public function updatehtaccess()
	{
		$this->container->session->set('htaccessRequired', false);
		$this->container->session->set('htaccessRenamed', false);
		$this->container->session->set('htaccessGenerated', false);
		$this->container->session->set('htaccessContents', '');

		// Check if I need to do anything i.e. if the site is installed on a different URL
		$config     = AModel::getAnInstance('Configuration', 'AngieModel', [], $this->container);
		$oldHomeURL = $config->get('oldurl');
		$newHomeURL = $config->get('homeurl');

		if ($newHomeURL == $oldHomeURL)
		{
			return true;
		}

		$this->container->session->set('htaccessRequired', true);

		// Check if I was able to write the wp-config.php file earlier. If not, I cannot proceed (can't create .htaccess)
		$writtenWpConfig = $this->container->session->get('writtenConfiguration', false);

		if (!$writtenWpConfig)
		{
			return false;
		}

		// Remove the .htaccess file, if present, keeping a backup copy of the file being replaced
		$pathHtaccess = APATH_ROOT . '/.htaccess';
		$pathHtBak    = APATH_ROOT . '/htaccess.bak';
		$newBak       = APATH_ROOT . '/.htaccess.akeebabackup';

		// -- null means we found no file to rename
		$renamed = null;

		if (file_exists($pathHtBak))
		{
			/**
			 * Prioritize renaming the htaccess.bak to .htaccess.akeebabackup. This is the file created by Kickstart
			 * and the integrated restoration when extracting the backup archive.
			 */
			$renamed = @rename($pathHtBak, $newBak);
		}
		elseif (file_exists($newBak))
		{
			/**
			 * The .htaccess.akeebabackup file already exists. DO NOT REPLACE IT even if .htaccess exists. This prevents
			 * the original file being lost when running this feature twice or more in a row. We still set $renamed to
			 * true to issue the notices that the old configuration file has been renamed but not removed.
			 */
			$renamed = true;
		}
		elseif (file_exists($pathHtaccess))
		{
			/**
			 * Finally, we have a .htaccess file and no backup. Rename it.
			 */
			$renamed = @rename($pathHtaccess, $newBak);
		}

		/**
		 * There is no .htaccess file to begin with. What am I doing here? Go away.
		 */
		if (is_null($renamed))
		{
			$this->container->session->set('htaccessRequired', false);

			return false;
		}

		$this->container->session->set('htaccessRenamed', $renamed);

		if (file_exists($pathHtaccess))
		{
			@unlink($pathHtaccess);
		}

		// The next bit may die. So let's save the data here.
		$this->container->session->saveData();

		@ob_start();

		// Load enough of WordPress to have access to WP_Rewrite
		require_once APATH_SITE . '/wp-config.php';
		include APATH_SITE . '/wp-admin/includes/misc.php';

		/**
		 * We will only automatically overwrite the .htaccess file if there was a .htaccess.akeebabackup file OR if we
		 * renamed an existing .htaccess / htaccess.bak file to .htaccess.akeebabackup.
		 */

		if (is_multisite())
		{
			/**
			 * Multisite installations can't use WP_Rewrite. All we can do is lift code from
			 * wp-admin/includes/network.php (which displays the recommended .htaccess to the network admin) and use the
			 * resulting .htaccess file verbatim.
			 */
			$htaccessCode = $this->getMultisitesHtaccess();

			if ($renamed)
			{
				$written = file_put_contents($pathHtaccess, $htaccessCode) !== false;
			}
			else
			{
				$written = false;
			}

			if (!$written)
			{
				$this->container->session->set('htaccessContents', $htaccessCode);
			}
			else
			{
				$this->container->session->set('htaccessGenerated', true);
			}
		}
		else
		{
			// NB! Going through WP_Rewrite only works on NON-multisite installations
			/** @var WP_Rewrite $wp_rewrite */
			global $wp_rewrite;

			if ($renamed)
			{
				$wp_rewrite->flush_rules();
				$written = file_exists($pathHtaccess);
			}

			if (!$written)
			{
				$isCP   = function_exists('classicpress_version');
				$marker = $isCP ? 'ClassicPress' : 'WordPress';
				$rules  = $wp_rewrite->mod_rewrite_rules();
				$rules  = "# BEGIN $marker\n$rules\n# END $marker\n";
				$this->container->session->set('htaccessContents', $rules);
			}
			else
			{
				$this->container->session->set('htaccessGenerated', true);
			}
		}

		/**
		 * If we managed to create a new .htaccess file we are going to put a header at the top explaining what we did
		 * and why.
		 */
		if ($written)
		{
			/**
			 * We will only show the message that the original .htaccess was renamed if we did find and rename a file OR if
			 * there was already a .htaccess.akeebabackup file.
			 */
			$renameNotice = <<< TXT
###
### The original file IS  NOT  LOST. It is still saved as .htaccess.akeebabackup
### in your site's root. If you had custom rules you  want to keep please review
### it and transfer these rules to this new file by hand.
###
TXT;

			if (!$renamed)
			{
				$renameNotice = "###";
			}

			$htaccessContents = file_get_contents($pathHtaccess);
			$htaccessContents = trim($htaccessContents);
			$htaccessContents = <<< TXT
# BEGIN AkeebaBackupRestoredYourSite

################################################################################
###
### This site has been restored from a backup taken with Akeeba Backup.
###
### You may have to modify this file manually.
###
################################################################################
###
### URL of the site you backed up:   $oldHomeURL
### URL of the site you restored to: $newHomeURL
###
### You  restored  your  site to  a different  URL.  As a  result your  existing
### .htaccess file would not  work. It would  break your  site.  For this reason
### the  restoration script  of Akeeba Backup  asked WordPress  to create  a new
### .htaccess file.
$renameNotice 
### If you  had any  cache, security  or other plugins which made changes to the
### .htaccess file (e.g. SuperCache,  Admin Tools,  WordFence,  iThemes Security
### etc) you  will need  to have them apply these  changes again on the restored
### site.
###
### When you are done changing this file please remove this section.
###
################################################################################

# END AkeebaBackupRestoredYourSite

{$htaccessContents}

TXT;
			file_put_contents($pathHtaccess, $htaccessContents);
		}

		@ob_end_clean();

		$this->handleCoreFilesInSubdirectory();

		return true;
	}

	/**
	 * Get the .htaccess content for a multisite installation. WordPress does not have a way for doing that
	 * automatically. It does have code in wp-admin/includes/network.php to show this information to the network admin
	 * and instructs them to write it manually, which is just plain daft (if you can generate the code you can
	 * definitely write it to disk, too). So we simply lifted this code and put it here.
	 *
	 * @return string
	 */
	protected function getMultisitesHtaccess()
	{
		$slashed_home      = trailingslashit( get_option( 'home' ) );
		$base              = parse_url( $slashed_home, PHP_URL_PATH );
		$document_root_fix = str_replace( '\\', '/', realpath( $_SERVER['DOCUMENT_ROOT'] ) );
		$abspath_fix       = str_replace( '\\', '/', ABSPATH );
		$home_path         = 0 === strpos( $abspath_fix, $document_root_fix ) ? $document_root_fix . $base : get_home_path();
		$wp_siteurl_subdir = preg_replace( '#^' . preg_quote( $home_path, '#' ) . '#', '', $abspath_fix );
		$rewrite_base      = ! empty( $wp_siteurl_subdir ) ? ltrim( trailingslashit( $wp_siteurl_subdir ), '/' ) : '';

		$ms_files_rewriting = '';
		$subdomain_install = is_subdomain_install();
		$subdir_match          = $subdomain_install ? '' : '([_0-9a-zA-Z-]+/)?';
		$subdir_replacement_01 = $subdomain_install ? '' : '$1';
		$subdir_replacement_12 = $subdomain_install ? '$1' : '$2';


		if ( is_multisite() && get_site_option( 'ms_files_rewriting' ) ) {
			$ms_files_rewriting = "\n# uploaded files\nRewriteRule ^";
			$ms_files_rewriting .= $subdir_match . "files/(.+) {$rewrite_base}" . WPINC . "/ms-files.php?file={$subdir_replacement_12} [L]" . "\n";
		}

		return <<<EOF
RewriteEngine On
RewriteBase {$base}
RewriteRule ^index\.php$ - [L]
{$ms_files_rewriting}
# add a trailing slash to /wp-admin
RewriteRule ^{$subdir_match}wp-admin$ {$subdir_replacement_01}wp-admin/ [R=301,L]

RewriteCond %{REQUEST_FILENAME} -f [OR]
RewriteCond %{REQUEST_FILENAME} -d
RewriteRule ^ - [L]
RewriteRule ^{$subdir_match}(wp-(content|admin|includes).*) {$rewrite_base}{$subdir_replacement_12} [L]
RewriteRule ^{$subdir_match}(.*\.php)$ {$rewrite_base}$subdir_replacement_12 [L]
RewriteRule . index.php [L]

EOF;

	}

	/**
	 * Some WordPress sites have their core files in a different subdirectory than the one used to access the site.
	 *
	 * For example:
	 *
	 * Home Address (homeurl)      -- typed by visitors to access your site -- https://www.example.com/foobar
	 * WordPress Address (siteurl) -- where WordPress core files are stored -- https://www.example.com/foobar/wordpress_dir
	 *
	 * In these cases we are restoring into the <webRoot>/foobar/wordpress_dir folder and our .htaccess file is there as
	 * well. However, we need to copy the .htaccess in <webRoot>foobar, copy the index.php in <webRoot>foobar and modify
	 * the index.php to load stuff from the <webRoot>/foobar/wordpress_dir subdirectory.
	 *
	 * This method handles these necessary changes.
	 *
	 * @return  bool  False if an error occurred, e.g. an unwriteable file
	 */
	protected function handleCoreFilesInSubdirectory()
	{
		/** @var AngieModelWordpressConfiguration $config */
		$config       = AModel::getAnInstance('Configuration', 'AngieModel', [], $this->container);

		// Get the URL path (relative to domain root) where the new site is installed
		$newHomeURL    = $config->get('homeurl');
		$newHomeURI    = new AUri($newHomeURL);
		$newHomeFolder = $newHomeURI->getPath();
		$newHomeFolder = trim($newHomeFolder, '/\\');

		// Get the site's URL
		$newCoreFilesURL    = $config->get('siteurl');
		$newCoreFilesURI    = new AUri($newCoreFilesURL);
		$newCoreFilesFolder = $newCoreFilesURI->getPath();
		$newCoreFilesFolder = trim($newCoreFilesFolder, '/\\');

		// Do I really have to do anything?
		if ($newCoreFilesURL == $newHomeURL)
		{
			return true;
		}

		if (strpos($newCoreFilesFolder, $newHomeFolder) !== 0)
		{
			// I have no clue where to put the files so I'll do nothing at all :s
			return true;
		}

		// $newHomeFolder is WITHOUT /wordpress_dir (/foobar); $path is the one WITH /wordpress_dir (/foobar/wordpress_dir)
		$newHomeFolder        = ltrim($newHomeFolder, '/\\');
		$newCoreFilesFolder   = ltrim($newCoreFilesFolder, '/\\');
		$homeFolderParts      = explode('/', $newHomeFolder);
		$coreFilesFolderParts = explode('/', $newCoreFilesFolder);

		$numHomeParts         = count($homeFolderParts);
		$coreFilesFolderParts = array_slice($coreFilesFolderParts, $numHomeParts);

		// Relative path from HOME to SITE (WP) root
		$relativeCoreFilesPath = implode('/', $coreFilesFolderParts);

		// How many directories above the root (where we are restoring) is our site's root
		$levelsUp = count($coreFilesFolderParts);

		// Determine the path where the index.php and .htaccess files will be written to
		$targetPath = APATH_ROOT . str_repeat('/..', $levelsUp);
		$targetPath = realpath($targetPath) ? realpath($targetPath) : $targetPath;

		// Copy the .htaccess and index.php files
		if (!@copy(APATH_ROOT . '/.htaccess', $targetPath . '/.htaccess'))
		{
			return false;
		}

		if (!@copy(APATH_ROOT . '/index.php', $targetPath . '/index.php'))
		{
			return false;
		}

		// Edit the index.php file
		$fileName     = $targetPath . '/index.php';
		$fileContents = @file($fileName);

		if (empty($fileContents))
		{
			return false;
		}

		foreach ($fileContents as $index => $line)
		{
			$line = trim($line);

			if (strstr($line, 'wp-blog-header.php') && (strpos($line, 'require') === 0))
			{
				$line = "require( dirname( __FILE__ ) . '/$relativeCoreFilesPath/wp-blog-header.php' );";
			}

			$fileContents[$index] = $line;
		}

		$fileContents = implode("\n", $fileContents);
		@file_put_contents($fileName, $fileContents);

		return true;
	}

}
